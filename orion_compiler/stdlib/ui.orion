// Orion Standard UI Library
// Version 0.3
module ui;
use draw;

// A simple text label component.
component Label {
    x: 0;
    y: 0;
    text: "Label";
    color: "#000000";
    fontSize: 16;

    render() {
        draw.text({
            x: this.x,
            y: this.y,
            text: this.text,
            color: this.color,
            fontSize: this.fontSize
        });
    }
}

// A stateful checkbox component.
component Checkbox {
    x: 0;
    y: 0;
    size: 20;
    width: 20;
    height: 20;
    label: "";
    onChange: nil;

    state: { "is_checked": false };

    onClick() {
        this.state["is_checked"] = !(this.state["is_checked"]);
        if (!(this.onChange == nil)) {
            var callback = this.onChange;
            callback(this.state["is_checked"]);
        }
    }

    render() {
        draw.box({ x: this.x, y: this.y, width: this.size, height: this.size, color: "#AAAAAA" });
        if (this.state["is_checked"]) {
            draw.box({ x: this.x + 4, y: this.y + 4, width: this.size - 8, height: this.size - 8, color: "#3498DB" });
        }
        if (!(this.label == "")) {
            draw.text({ x: this.x + this.size + 10, y: this.y + (this.size / 2) + 6, text: this.label, color: "#000000", fontSize: 16 });
        }
    }
}

// A simple button component.
component Button {
    x: 0;
    y: 0;
    width: 100;
    height: 40;
    text: "Button";
    color: "#DDDDDD";
    hover_color: "#EEEEEE";
    onClick: nil;

    state: { "is_hovering": false };

    onMouseEnter() {
        this.state["is_hovering"] = true;
    }

    onMouseLeave() {
        this.state["is_hovering"] = false;
    }

    render() {
        var current_color = this.color;
        if (this.state["is_hovering"]) {
            current_color = this.hover_color;
        }
        draw.box({ x: this.x, y: this.y, width: this.width, height: this.height, color: current_color });
        var text_width = draw.measure_text(this.text, 16);
        var text_x = this.x + (this.width - text_width) / 2;
        var text_y = this.y + (this.height / 2) + 6;
        draw.text({ x: text_x, y: text_y, text: this.text, color: "#000000", fontSize: 16 });
    }
}

// A scrollable view for containing content that is larger than the view area.
component ScrollView {
    x: 0;
    y: 0;
    width: 200;
    height: 200;
    children: [];

    state: {
        "scroll_y": 0.0,
        "content_height": 0.0 // Will be calculated by the layout engine
    };

    onMouseWheel(event) {
        // scroll speed
        var scroll_speed = 20;
        var new_scroll_y = this.state["scroll_y"] + (event.y * scroll_speed);

        // Clamping
        var max_scroll = this.state["content_height"] - this.height;
        if (max_scroll < 0) { max_scroll = 0; }
        if (new_scroll_y < 0) { new_scroll_y = 0; }
        if (new_scroll_y > max_scroll) { new_scroll_y = max_scroll; }

        this.state["scroll_y"] = new_scroll_y;
    }

    render() {
        // The ScrollView itself doesn't draw anything, it just provides a clipping
        // area and returns its children to be rendered by the layout engine.
        return this.children;
    }
}
